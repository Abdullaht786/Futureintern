# -*- coding: utf-8 -*-
"""House_price_prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/house-price-prediction-5817cf73-073f-4bff-8e7e-3b41d74bfad6.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20241015/auto/storage/goog4_request%26X-Goog-Date%3D20241015T063950Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D95093a73dce79f9004857f05b21bb5f822c513157f418a19a45d55847e95d2e88771efd6e0ac4d68a17db47455b35f4598fdff52e3c974cef44a80cded8e6ed0c5bb0b8202ce75c285858ef82cfa92a12c33126267b52becd4c1b4d857b31fc2ec74d5e6e7d8c8c8cbccb44ca17ddec09f17994adcf323111612423331ee186daa09f4083606ea2a11a80bfb6d84222c5f03d8521064cdc979d3a4b162943f68a115a79f34c12aee4e2a535671fdb6d665b6a9e60b79ae02f6f1b495ad71ba1fc7dc95f58cfc517505b82a813d63712b44028ac7669c3c4a761f3969bfe23ae47a6bdd1cd42fcd4a747e101eb0dca4d6c4645936c25bdf765c1f4bbbbd12f87a
"""

import numpy as np
import pandas as pd
import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

from sklearn.preprocessing import StandardScaler
from sklearn.impute import SimpleImputer
import matplotlib.pyplot as plt

# Load the dataset
url = '/kaggle/input/housedata/data.csv'
raw_data = pd.read_csv(url)

# Get a summary of the DataFrame.
raw_data.info()

# Display the min and max values for each numerical column
for column in raw_data.select_dtypes(np.number).columns:
    max_value = raw_data[column].max()  # Maximum value of the column
    min_value = raw_data[column].min()  # Minimum value of the column
    print(f"{column} with minimum value: {min_value} and maximum value: {max_value}")

# Specify the column to filter for outliers
columns_to_filter = ['price','sqft_living', 'sqft_lot']

# Remove outliers using the IQR method
for column in columns_to_filter:
    Q1 = raw_data[column].quantile(0.25)  # First quartile
    Q3 = raw_data[column].quantile(0.75)   # Third quartile
    IQR = Q3 - Q1                          # Interquartile range
    lower_bound = Q1 - 1.5 * IQR           # Lower bound for outlier detection
    upper_bound = Q3 + 1.5 * IQR           # Upper bound for outlier detection

    # Remove rows where the column value is outside the bounds
    raw_data = raw_data[(raw_data[column] >= lower_bound) & (raw_data[column] <= upper_bound)]

# Create 'age' feature based on the year built
raw_data['age'] = 2024 - raw_data['yr_built']

# Create a binary 'rennovated' feature indicating whether the property has been renovated
raw_data['rennovated'] = raw_data['yr_renovated'].apply(lambda x: 0 if x == 0 else 1)

# Standardize specified numerical features
scaler = StandardScaler()
raw_data[['bedrooms', 'bathrooms', 'floors', 'waterfront', 'view', 'condition',
           'sqft_living', 'sqft_lot', 'sqft_above', 'sqft_basement', 'age']] = \
    scaler.fit_transform(raw_data[['bedrooms', 'bathrooms', 'floors', 'waterfront',
                                     'view', 'condition', 'sqft_living', 'sqft_lot',
                                     'sqft_above', 'sqft_basement', 'age']])

# Display the first few rows after scaling
raw_data.head()

# Extract the state from 'statezip' column using regex
raw_data['state'] = raw_data['statezip'].str.extract(r'([A-Z]+)')

# Drop columns that are no longer needed for analysis
raw_data = raw_data.drop(['street', 'statezip', 'yr_built', 'yr_renovated', 'date'], axis=1)

# Convert categorical variables into dummy/indicator variables
raw_data = pd.get_dummies(raw_data, columns=['city', 'state', 'country'], drop_first=True)

# Display info to confirm dropped columns
raw_data.info()

# Identify boolean columns in the dataset
boolean_columns = raw_data.select_dtypes(np.bool_).columns

# Convert boolean columns to integer type (0 or 1)
raw_data[boolean_columns] = raw_data[boolean_columns].astype(int)

# Display the first few rows after conversion
raw_data.head()

# Reset the index of the DataFrame
raw_data = raw_data.reset_index(drop=True)

# Import necessary libraries for model training
from sklearn.linear_model import LassoCV
from sklearn.model_selection import train_test_split

# Define features (X) and target variable (y)
X = raw_data.drop('price', axis=1)  # Features
y = raw_data['price']                # Target variable

# Split the data into training and testing sets (80% train, 20% test)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Fit a Lasso regression model with cross-validation to select important features
lasso = LassoCV(cv=5).fit(X_train, y_train)

# Get the coefficients of the model and filter for non-zero coefficients (selected features)
coef = pd.Series(lasso.coef_, index=X_train.columns)

# Print the features selected by Lasso
print('Selected features by Lasso:', coef[coef != 0].index)

# Filter the original data to keep only the selected features
filtered_data = raw_data[coef[coef != 0].index]

# Split the filtered data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(filtered_data, y, test_size=0.2, random_state=42)

# Import the Linear Regression model
from sklearn.linear_model import LinearRegression

# Create an instance of the Linear Regression model
model = LinearRegression()

# Fit the model to the training data
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Import metrics for evaluating the model
from sklearn.metrics import mean_squared_error, r2_score,mean_absolute_error

# Calculate R-squared score
r2 = round(r2_score(y_test, y_pred),2)

# Calculate Mean Squared Error (MSE)
mse = round(mean_squared_error(y_test, y_pred),2)

# Calculate Root Mean Squared Error (RSME)
rsme = round(mse ** 0.5,2)

mae = round(mean_absolute_error(y_test,y_pred),2)

# Output (R-squared, MSE, MAE and RSME)
r2, mse, mae, rsme

#Residual Plot
residual = y_test - y_pred
plt.figure(figsize=(10,6))
plt.scatter(y_pred,residual,alpha=0.75)
plt.axhline(0,color = 'red',linestyle = '--')
plt.title('Residuals Plot')
plt.xlabel('Predicted Prices')
plt.ylabel('Residuals')
plt.show()

#Actual vs. Predicted Price plot:
plt.figure(figsize = (10,6))
plt.scatter(y_pred, y_test, alpha=0.75)
plt.plot([y_test.min(), y_test.max()],[y_test.min(), y_test.max()],'--r',lw=2)
plt.title('Actual vs. Predicted Prices')
plt.xlabel('Actual Prices')
plt.ylabel('Predicted Prices')
plt.show()